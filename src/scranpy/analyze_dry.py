# DO NOT MODIFY THIS FILE! This is automatically generated by '../../scripts/dryrun.py'
# from the source file 'analyze_live.py', modify that instead and rerun the script.

from .analyze_live import AnalyzeOptions

def __dry_analyze(options: AnalyzeOptions=AnalyzeOptions()) -> str:
    __commands = ['import scranpy', 'import copy', '']
    __commands.append('results = AnalyzeResults()')
    __commands.append('subsets = {}')
    if options.quality_control.mito_subset is not None:
        if isinstance(options.quality_control.mito_subset, str):
            __commands.append("subsets['mito'] = scranpy.quality_control.guess_mito_from_symbols(features, options.quality_control.mito_subset)")
        elif isinstance(options.quality_control.mito_subset, bool):
            __commands.append("subsets['mito'] = scranpy.quality_control.guess_mito_from_symbols(features)")
        else:
            raise ValueError(f'Unsupported value provided for `qc_mito_subset`: {options.quality_control.mito_subset}')
    __commands.append('results.quality_control.subsets = subsets')
    __commands.append('rna_options = copy.deepcopy(options.quality_control.per_cell_rna_qc_metrics)')
    __commands.append('rna_options.subsets = subsets')
    __commands.append('results.quality_control.qc_metrics = scranpy.quality_control.per_cell_rna_qc_metrics(matrix, options=rna_options)')
    __commands.append('results.quality_control.qc_thresholds = scranpy.quality_control.suggest_rna_qc_filters(results.quality_control.qc_metrics, options=options.quality_control.suggest_rna_qc_filters)')
    __commands.append('results.quality_control.qc_filter = scranpy.quality_control.create_rna_qc_filter(results.quality_control.qc_metrics, results.quality_control.qc_thresholds, options.quality_control.create_rna_qc_filter)')
    __commands.append('results.quality_control.filtered_cells = scranpy.quality_control.filter_cells(matrix, filter=results.quality_control.qc_filter)')
    __commands.append('normed = scranpy.normalization.log_norm_counts(results.quality_control.filtered_cells, options=options.normalization.log_norm_counts)')
    __commands.append('results.feature_selection.gene_variances = scranpy.feature_selection.model_gene_variances(normed, options=options.feature_selection.model_gene_variances)')
    __commands.append("results.feature_selection.hvgs = scranpy.feature_selection.choose_hvgs(results.feature_selection.gene_variances.column('residuals'), options=options.feature_selection.choose_hvgs)")
    __commands.append('pca_options = copy.deepcopy(options.dimensionality_reduction.run_pca)')
    __commands.append('pca_options.subset = results.feature_selection.hvgs')
    __commands.append('results.dimensionality_reduction.pca = scranpy.dimensionality_reduction.run_pca(normed, options=options.dimensionality_reduction.run_pca)')
    __commands.append('(callback, graph, remaining_threads) = scranpy.run_neighbor_suite(results.dimensionality_reduction.pca.principal_components, build_neighbor_index_options=options.nearest_neighbors.build_neighbor_index, find_nearest_neighbors_options=options.nearest_neighbors.find_nearest_neighbors, run_umap_options=options.dimensionality_reduction.run_umap, run_tsne_options=options.dimensionality_reduction.run_tsne, build_snn_graph_options=options.clustering.build_snn_graph, num_threads=options.nearest_neighbors.find_nearest_neighbors.num_threads)')
    __commands.append('results.clustering.build_snn_graph = graph')
    __commands.append('results.clustering.clusters = results.clustering.build_snn_graph.community_multilevel(resolution=options.clustering.resolution).membership')
    __commands.append('marker_options = copy.deepcopy(options.marker_detection)')
    __commands.append('marker_options.num_threads = remaining_threads')
    __commands.append('results.marker_detection.markers = scranpy.marker_detection.score_markers(normed, grouping=results.clustering.clusters, options=options.marker_detection.score_markers)')
    __commands.append('embeddings = callback()')
    __commands.append('results.dimensionality_reduction.tsne = embeddings[0]')
    __commands.append('results.dimensionality_reduction.umap = embeddings[1]')
    return '\n'.join(__commands)
