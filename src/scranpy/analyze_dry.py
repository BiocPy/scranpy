# DO NOT MODIFY THIS FILE! This is automatically generated by '../../scripts/dryrun.py'
# from the source file 'analyze_live.py', modify that instead and rerun the script.

from .analyze_live import AnalyzeOptions

def __dry_analyze(options: AnalyzeOptions=AnalyzeOptions()) ->str:
    __commands = ['import scranpy\n', 'import copy\n']
    __commands.append('results = AnalyzeResults()\n')
    __commands.append('subsets = {}\n')
    if options.quality_control.mito_subset is not None:
        if isinstance(options.quality_control.mito_subset, str):
            __commands.append(
                """subsets['mito'] = scranpy.quality_control.guess_mito_from_symbols(features,
    options.quality_control.mito_subset)
"""
                )
        elif isinstance(options.quality_control.mito_subset, bool):
            __commands.append(
                """subsets['mito'] = scranpy.quality_control.guess_mito_from_symbols(features)
"""
                )
        else:
            raise ValueError(
                f'Unsupported value provided for `qc_mito_subset`: {options.quality_control.mito_subset}'
                )
    __commands.append('results.quality_control.subsets = subsets\n')
    __commands.append(
        """rna_options = copy.deepcopy(options.quality_control.per_cell_rna_qc_metrics)
"""
        )
    __commands.append('rna_options.subsets = subsets\n')
    __commands.append(
        """results.quality_control.qc_metrics = (scranpy.quality_control.
    per_cell_rna_qc_metrics(matrix, options=rna_options))
"""
        )
    __commands.append(
        """results.quality_control.qc_thresholds = (scranpy.quality_control.
    suggest_rna_qc_filters(results.quality_control.qc_metrics, options=
    options.quality_control.suggest_rna_qc_filters))
"""
        )
    __commands.append(
        """results.quality_control.qc_filter = (scranpy.quality_control.
    create_rna_qc_filter(results.quality_control.qc_metrics, results.
    quality_control.qc_thresholds, options.quality_control.
    create_rna_qc_filter))
"""
        )
    __commands.append(
        """results.quality_control.filtered_cells = scranpy.quality_control.filter_cells(
    ptr, filter=results.quality_control.qc_filter)
"""
        )
    __commands.append(
        """results.normalization.log_norm_counts = scranpy.normalization.log_norm_counts(
    results.quality_control.filtered_cells, options=options.normalization.
    log_norm_counts)
"""
        )
    __commands.append(
        """results.feature_selection.gene_variances = (scranpy.feature_selection.
    model_gene_variances(results.normalization.log_norm_counts, options=
    options.feature_selection.model_gene_variances))
"""
        )
    __commands.append(
        """results.feature_selection.hvgs = scranpy.feature_selection.choose_hvgs(results
    .feature_selection.gene_variances.column('residuals'), options=options.
    feature_selection.choose_hvgs)
"""
        )
    __commands.append(
        'pca_options = copy.deepcopy(options.dimensionality_reduction.run_pca)\n'
        )
    __commands.append('pca_options.subset = results.feature_selection.hvgs\n')
    __commands.append(
        """results.dimensionality_reduction.pca = (scranpy.dimensionality_reduction.
    run_pca(results.normalization.log_norm_counts, options=options.
    dimensionality_reduction.run_pca))
"""
        )
    __commands.append(
        """callback, graph, remaining_threads = scranpy.run_neighbor_suite(results.
    dimensionality_reduction.pca.principal_components,
    build_neighbor_index_options=options.nearest_neighbors.
    build_neighbor_index, find_nearest_neighbors_options=options.
    nearest_neighbors.find_nearest_neighbors, run_umap_options=options.
    dimensionality_reduction.run_umap, run_tsne_options=options.
    dimensionality_reduction.run_tsne, build_snn_graph_options=options.
    clustering.build_snn_graph, num_threads=options.nearest_neighbors.
    find_nearest_neighbors.num_threads)
"""
        )
    __commands.append('results.clustering.build_snn_graph = graph\n')
    __commands.append(
        """results.clustering.clusters = (results.clustering.build_snn_graph.
    community_multilevel(resolution=options.clustering.resolution).membership)
"""
        )
    __commands.append(
        'marker_options = copy.deepcopy(options.marker_detection)\n')
    __commands.append('marker_options.num_threads = remaining_threads\n')
    __commands.append(
        """results.marker_detection.markers = scranpy.marker_detection.score_markers(
    results.normalization.log_norm_counts, grouping=results.clustering.
    clusters, options=options.marker_detection.score_markers)
"""
        )
    __commands.append('embeddings = callback()\n')
    __commands.append('results.dimensionality_reduction.tsne = embeddings[0]\n'
        )
    __commands.append('results.dimensionality_reduction.umap = embeddings[1]\n'
        )
    return ''.join(__commands)

